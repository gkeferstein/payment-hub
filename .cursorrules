# Universal Commerce HUB - Cursor Rules
# CTO Best Practices & Development Standards

## üîÑ Arbeitsprozess & Entwicklungsmethodik

### Iterative Entwicklung mit To-Do-Management
- **IMMER zuerst**: Saubere, spezifische To-Dos definieren bevor Code geschrieben wird
- **To-Do-Struktur**: Jedes To-Do muss klar, testbar und abgrenzbar sein
- **Schritt-f√ºr-Schritt**: Nur EIN To-Do zur Zeit bearbeiten
- **Test-First**: Jeder Schritt MUSS getestet sein, bevor der n√§chste beginnt
- **Keine Parallel-Entwicklung**: Kein neues Feature starten, wenn das aktuelle nicht getestet ist

### To-Do-Definition (Pflicht vor jedem Feature)
Jedes To-Do MUSS enthalten:
1. **Klare Beschreibung**: Was wird implementiert?
2. **Akzeptanzkriterien**: Wann ist es fertig?
3. **Test-Plan**: Wie wird es getestet?
4. **Abh√§ngigkeiten**: Was muss vorher fertig sein?
5. **Sch√§tzung**: Realistische Zeitsch√§tzung

### Entwicklungszyklus (STRICT)
```
1. To-Do definieren & dokumentieren
   ‚Üì
2. Tests schreiben (TDD wenn m√∂glich)
   ‚Üì
3. Minimaler Code f√ºr To-Do
   ‚Üì
4. Tests laufen lassen & gr√ºn bekommen
   ‚Üì
5. Code-Review (selbst oder Team)
   ‚Üì
6. Linting & Formatting pr√ºfen
   ‚Üì
7. Integration testen (falls relevant)
   ‚Üì
8. To-Do als "Done" markieren
   ‚Üì
9. N√ÑCHSTES To-Do starten
```

### Testing zwischen Schritten
- **Unit Tests**: Nach jeder Funktion/Methode
- **Integration Tests**: Nach jedem API-Endpunkt
- **E2E Tests**: Nach jedem kompletten Flow
- **Manuelle Tests**: Nach jedem gr√∂√üeren Feature
- **Kein Commit**: Ohne gr√ºne Tests

### To-Do-Gr√∂√üe
- **Ideal**: 1-4 Stunden Arbeit
- **Maximum**: 1 Tag Arbeit
- **Zu gro√ü?**: To-Do in kleinere To-Dos aufteilen
- **Zu klein?**: Mehrere zusammengeh√∂rige To-Dos zusammenfassen

### Definition of Done (DoD)
Ein To-Do ist NUR fertig wenn:
- [ ] Code implementiert
- [ ] Tests geschrieben & gr√ºn
- [ ] Linting bestanden
- [ ] Code-Review durchgef√ºhrt (falls Team vorhanden)
- [ ] Dokumentation aktualisiert (falls n√∂tig)
- [ ] Keine bekannten Bugs
- [ ] Integration funktioniert (falls relevant)

### Fehlerbehandlung im Prozess
- **Tests schlagen fehl?**: Code fixen, nicht Tests anpassen (au√üer Test war falsch)
- **Linting-Fehler?**: Sofort fixen, nicht ignorieren
- **Unklare Anforderungen?**: STOPPEN, kl√§ren, dann weiter
- **Technische Schulden entdeckt?**: In separates To-Do auslagern, nicht jetzt fixen

### Kommunikation
- **Blockiert?**: Sofort kommunizieren, nicht stundenlang gr√ºbeln
- **To-Do gr√∂√üer als gedacht?**: Aufteilen oder Sch√§tzung anpassen
- **Unklarheit?**: Fragen stellen, nicht raten

## üèóÔ∏è Architektur-Prinzipien

### Modularer Monolith (NICHT Microservices)
- Wir bauen einen modularen Monolithen, keine Microservices
- Klare Dom√§nentrennung: Order, Payment, Customer, Event
- Jede Dom√§ne hat eigene Services, aber l√§uft im selben Prozess
- Keine verteilten Transaktionen - alles in einer DB
- Einfache Skalierung durch horizontales Scaling des gesamten Monolithen

### Single Source of Truth
- Die HUB-Datenbank ist die einzige Quelle der Wahrheit f√ºr Orders & Payments
- Externe Systeme (WooCommerce, POS) sind nur SPOKES - keine Autorit√§t
- Alle Status-√Ñnderungen gehen durch den HUB
- Keine direkte Kommunikation zwischen SPOKES

### Entkopplung & Abstraktion
- HUB kennt keine WooCommerce-spezifischen Details
- Payment-Provider sind √ºber Adapter abstrahiert
- Channels (Woo/POS/B2B) sind austauschbar
- Keine direkten Abh√§ngigkeiten zu externen Systemen im Core

## üîí Sicherheit & API-Design

### API-Sicherheit
- ALLE API-Endpunkte M√úSSEN authentifiziert sein (API Keys oder OAuth2)
- Webhook-Endpunkte M√úSSEN Signaturen validieren (Stripe, BTCPay)
- Rate Limiting auf allen √∂ffentlichen Endpunkten
- Input Validation auf allen Endpunkten (JSON Schema)
- Keine SQL-Injection: IMMER Prepared Statements / ORM
- Keine direkten DB-Queries mit String-Interpolation

### API-Versionierung
- Alle Endpunkte unter `/api/v1/` versionieren
- Breaking Changes = neue Version (`/api/v2/`)
- Backward Compatibility f√ºr mindestens 1 Major Version
- Deprecation-Warnungen in Headers

### Idempotenz (KRITISCH)
- ALLE POST/PUT/PATCH Endpunkte M√úSSEN idempotent sein
- Idempotency-Key im Header erforderlich f√ºr kritische Operationen
- Duplikate erkennen und gleiche Response zur√ºckgeben
- Keine doppelten Orders/Payments bei Retries

### Webhook-Sicherheit
- Webhook-Signaturen IMMER validieren (Stripe: X-Stripe-Signature, BTCPay: BTCPay-Sig)
- Webhook-Payloads niemals blind vertrauen
- Rate Limiting auf Webhook-Endpunkten
- Idempotente Webhook-Verarbeitung (gleiche Webhook-ID = keine Duplikate)

## üíæ Datenbank-Design

### Transaktionssicherheit
- Kritische Operationen (Order erstellen, Payment verarbeiten) in Transaktionen
- ACID-Compliance f√ºr alle Status-√Ñnderungen
- Keine Race Conditions bei Status-Updates
- Optimistic Locking f√ºr concurrent Updates

### Historisierung & Auditing
- JEDE Status-√Ñnderung in History-Tabellen schreiben
- `order_status_history` und `payment_status_history` sind Pflicht
- Timestamps mit Timezone (UTC)
- User/System-Information f√ºr Audit-Trail
- Keine L√∂schungen (Soft Deletes mit `deleted_at`)

### Datenintegrit√§t
- Foreign Keys f√ºr alle Referenzen
- NOT NULL Constraints wo sinnvoll
- Unique Constraints f√ºr Business-Keys (z.B. source + source_order_id)
- Check Constraints f√ºr Status-Validierung
- Indexes auf alle Foreign Keys und h√§ufig abgefragte Spalten

### Migrationen
- Alle DB-√Ñnderungen √ºber Migrations
- Keine direkten ALTER TABLE in Production
- Rollback-f√§hige Migrations
- Migrations sind versioniert und getestet

## üîÑ Event-Handling & Orchestrierung

### Event-Idempotenz
- Events M√úSSEN idempotent verarbeitet werden
- Event-ID als deduplizierungsschl√ºssel
- Gleiche Event-ID = keine doppelte Verarbeitung
- Event-History f√ºr Debugging & Reconciliation

### Retry-Mechanismen
- Exponential Backoff f√ºr fehlgeschlagene Events
- Dead Letter Queue f√ºr Events, die nach X Retries fehlschlagen
- Manuelle Retry-M√∂glichkeit f√ºr Support
- Keine endlosen Retry-Loops

### Callback-Mechanismen
- Callbacks an Channels (Woo/POS) M√úSSEN idempotent sein
- Retry-Logik f√ºr fehlgeschlagene Callbacks
- Timeout-Handling (max 30s f√ºr Callbacks)
- Callback-Status-Tracking (erfolgreich/fehlgeschlagen)

## üß™ Testing-Standards

### Test-Pyramide
- Unit Tests: 80% Coverage f√ºr Business-Logic
- Integration Tests: Alle API-Endpunkte
- E2E Tests: Komplette Flows (Woo ‚Üí HUB ‚Üí Stripe ‚Üí HUB ‚Üí Woo)
- Webhook-Simulationen: Stripe CLI, BTCPay Test-Server

### Test-Daten
- Keine Production-Daten in Tests
- Factory-Pattern f√ºr Test-Daten
- Isolierte Test-Datenbank
- Cleanup nach jedem Test

### Test-Kritikalit√§t
- Payment-Flows M√úSSEN getestet sein
- Order-Status-Transitions M√úSSEN getestet sein
- Webhook-Handler M√úSSEN getestet sein
- Idempotenz MUSS getestet sein

## üìù Code-Qualit√§t & Standards

### Clean Code
- Funktionen max. 50 Zeilen
- Klassen max. 300 Zeilen
- DRY: Don't Repeat Yourself
- SOLID-Prinzipien befolgen
- Meaningful Names (keine Abk√ºrzungen au√üer etablierten)

### Code-Organisation
```
/src
  /domains
    /order
      /services
      /models
      /repositories
    /payment
      /services
      /models
      /repositories
    /customer
    /event
  /adapters
    /woocommerce
    /stripe
    /btcpay
  /api
    /v1
      /orders
      /payments
      /webhooks
  /infrastructure
    /database
    /logging
    /monitoring
```

### Linting & Formatting
- ESLint/TSLint f√ºr TypeScript/JavaScript
- Prettier f√ºr Code-Formatting
- Pre-commit Hooks f√ºr Linting
- CI/CD Pipeline bricht bei Linting-Fehlern

### Type Safety
- TypeScript STRICTLY verwenden (kein `any`)
- Typen f√ºr alle API-Requests/Responses
- JSON Schema Validation f√ºr externe Inputs
- Runtime-Validierung mit Zod/Joi

## üöÄ Deployment & CI/CD

### CI/CD-Pipeline
- Automatische Tests bei jedem Commit
- Linting & Type-Checking vor Merge
- Automatisches Deployment nach erfolgreichen Tests
- Staging-Environment vor Production
- Rollback-Strategie vorhanden

### Environment-Management
- Keine Secrets im Code
- Environment Variables f√ºr alle Konfigurationen
- Separate Configs f√ºr Dev/Staging/Production
- Database Migrations automatisch bei Deployment

### Monitoring & Observability
- Strukturierte Logs (JSON-Format)
- Log-Level: DEBUG, INFO, WARN, ERROR
- Request-ID f√ºr Request-Tracking
- Health-Checks f√ºr alle Services
- Metrics f√ºr kritische Operationen (Order-Creation, Payment-Processing)

## üîå Integration-Standards

### Payment-Provider-Adapter
- Einheitliche Adapter-Interface f√ºr alle Provider
- Provider-spezifische Logik isoliert
- Fehlerbehandlung pro Provider
- Retry-Logik pro Provider konfigurierbar

### Channel-Adapter (WooCommerce, POS, B2B)
- Mapping-Logik in Adaptern, nicht im Core
- Channel-spezifische Daten in `metadata` JSON-Feld
- Callback-URLs pro Channel konfigurierbar
- Fehlerbehandlung & Reconciliation pro Channel

### Webhook-Handler
- Provider-spezifische Handler (Stripe, BTCPay)
- Signature-Validierung MUSS
- Idempotente Verarbeitung
- Async-Verarbeitung f√ºr lange Operationen

## üö´ NOT-TO-DO Liste

### Was NIEMALS in den HUB geh√∂rt:
- ‚ùå Frontend-Logik (UI, Templates, CSS)
- ‚ùå WooCommerce-spezifische Business-Logik
- ‚ùå Payment-Provider-spezifische Logik im Core (nur in Adaptern)
- ‚ùå Direkte Datenbank-Zugriffe ohne Repository-Pattern
- ‚ùå Hardcoded Secrets oder API-Keys
- ‚ùå Synchrones Blocking auf externe APIs (au√üer kritischen Flows)
- ‚ùå Keine Validierung von Inputs
- ‚ùå Keine Error-Handling
- ‚ùå Direkte SQL-Queries mit String-Interpolation
- ‚ùå Keine Transaktionen bei kritischen Operationen
- ‚ùå Keine Idempotenz-Checks
- ‚ùå Keine Webhook-Signatur-Validierung

## üìä Performance & Skalierung

### Datenbank-Performance
- Indexes auf alle Foreign Keys
- Indexes auf h√§ufig abgefragte Spalten (status, source, created_at)
- Partitioning f√ºr gro√üe History-Tabellen (nach Datum)
- Query-Optimierung (keine N+1 Queries)

### API-Performance
- Pagination f√ºr List-Endpunkte (max 100 Items pro Request)
- Caching f√ºr nicht-kritische Daten (Customer-Info, etc.)
- Async-Verarbeitung f√ºr nicht-kritische Operationen
- Timeout-Handling f√ºr externe API-Calls (max 30s)

## üîç Code-Review-Checkliste

Vor jedem Merge pr√ºfen:
- [ ] Idempotenz implementiert?
- [ ] Input Validation vorhanden?
- [ ] Error Handling vorhanden?
- [ ] Tests geschrieben?
- [ ] Linting bestanden?
- [ ] Keine Secrets im Code?
- [ ] Transaktionen f√ºr kritische Operationen?
- [ ] History-Tabellen aktualisiert?
- [ ] Logging vorhanden?
- [ ] Dokumentation aktualisiert?

## üéØ Priorit√§ten

### P0 (Kritisch - Blockiert Release)
- Payment-Processing funktioniert
- Order-Status-Synchronisation funktioniert
- Webhook-Signatur-Validierung
- Idempotenz f√ºr alle kritischen Endpunkte

### P1 (Wichtig - Sollte im MVP sein)
- WooCommerce Integration
- Stripe Integration
- Order/Payment History
- Error Handling & Logging

### P2 (Nice-to-Have - Kann sp√§ter kommen)
- BTCPay Integration
- POS Integration
- B2B-Vertragsstrecke
- Erweiterte Monitoring-Dashboards

---

**Diese Regeln sind bindend f√ºr alle Entwickler. Bei Fragen oder Unklarheiten: CTO konsultieren.**



## üîÑ Arbeitsprozess & Entwicklungsmethodik

### Iterative Entwicklung mit To-Do-Management
- **IMMER zuerst**: Saubere, spezifische To-Dos definieren bevor Code geschrieben wird
- **To-Do-Struktur**: Jedes To-Do muss klar, testbar und abgrenzbar sein
- **Schritt-f√ºr-Schritt**: Nur EIN To-Do zur Zeit bearbeiten
- **Test-First**: Jeder Schritt MUSS getestet sein, bevor der n√§chste beginnt
- **Keine Parallel-Entwicklung**: Kein neues Feature starten, wenn das aktuelle nicht getestet ist

### To-Do-Definition (Pflicht vor jedem Feature)
Jedes To-Do MUSS enthalten:
1. **Klare Beschreibung**: Was wird implementiert?
2. **Akzeptanzkriterien**: Wann ist es fertig?
3. **Test-Plan**: Wie wird es getestet?
4. **Abh√§ngigkeiten**: Was muss vorher fertig sein?
5. **Sch√§tzung**: Realistische Zeitsch√§tzung

### Entwicklungszyklus (STRICT)
```
1. To-Do definieren & dokumentieren
   ‚Üì
2. Tests schreiben (TDD wenn m√∂glich)
   ‚Üì
3. Minimaler Code f√ºr To-Do
   ‚Üì
4. Tests laufen lassen & gr√ºn bekommen
   ‚Üì
5. Code-Review (selbst oder Team)
   ‚Üì
6. Linting & Formatting pr√ºfen
   ‚Üì
7. Integration testen (falls relevant)
   ‚Üì
8. To-Do als "Done" markieren
   ‚Üì
9. N√ÑCHSTES To-Do starten
```

### Testing zwischen Schritten
- **Unit Tests**: Nach jeder Funktion/Methode
- **Integration Tests**: Nach jedem API-Endpunkt
- **E2E Tests**: Nach jedem kompletten Flow
- **Manuelle Tests**: Nach jedem gr√∂√üeren Feature
- **Kein Commit**: Ohne gr√ºne Tests

### To-Do-Gr√∂√üe
- **Ideal**: 1-4 Stunden Arbeit
- **Maximum**: 1 Tag Arbeit
- **Zu gro√ü?**: To-Do in kleinere To-Dos aufteilen
- **Zu klein?**: Mehrere zusammengeh√∂rige To-Dos zusammenfassen

### Definition of Done (DoD)
Ein To-Do ist NUR fertig wenn:
- [ ] Code implementiert
- [ ] Tests geschrieben & gr√ºn
- [ ] Linting bestanden
- [ ] Code-Review durchgef√ºhrt (falls Team vorhanden)
- [ ] Dokumentation aktualisiert (falls n√∂tig)
- [ ] Keine bekannten Bugs
- [ ] Integration funktioniert (falls relevant)

### Fehlerbehandlung im Prozess
- **Tests schlagen fehl?**: Code fixen, nicht Tests anpassen (au√üer Test war falsch)
- **Linting-Fehler?**: Sofort fixen, nicht ignorieren
- **Unklare Anforderungen?**: STOPPEN, kl√§ren, dann weiter
- **Technische Schulden entdeckt?**: In separates To-Do auslagern, nicht jetzt fixen

### Kommunikation
- **Blockiert?**: Sofort kommunizieren, nicht stundenlang gr√ºbeln
- **To-Do gr√∂√üer als gedacht?**: Aufteilen oder Sch√§tzung anpassen
- **Unklarheit?**: Fragen stellen, nicht raten

## üèóÔ∏è Architektur-Prinzipien

### Modularer Monolith (NICHT Microservices)
- Wir bauen einen modularen Monolithen, keine Microservices
- Klare Dom√§nentrennung: Order, Payment, Customer, Event
- Jede Dom√§ne hat eigene Services, aber l√§uft im selben Prozess
- Keine verteilten Transaktionen - alles in einer DB
- Einfache Skalierung durch horizontales Scaling des gesamten Monolithen

### Single Source of Truth
- Die HUB-Datenbank ist die einzige Quelle der Wahrheit f√ºr Orders & Payments
- Externe Systeme (WooCommerce, POS) sind nur SPOKES - keine Autorit√§t
- Alle Status-√Ñnderungen gehen durch den HUB
- Keine direkte Kommunikation zwischen SPOKES

### Entkopplung & Abstraktion
- HUB kennt keine WooCommerce-spezifischen Details
- Payment-Provider sind √ºber Adapter abstrahiert
- Channels (Woo/POS/B2B) sind austauschbar
- Keine direkten Abh√§ngigkeiten zu externen Systemen im Core

## üîí Sicherheit & API-Design

### API-Sicherheit
- ALLE API-Endpunkte M√úSSEN authentifiziert sein (API Keys oder OAuth2)
- Webhook-Endpunkte M√úSSEN Signaturen validieren (Stripe, BTCPay)
- Rate Limiting auf allen √∂ffentlichen Endpunkten
- Input Validation auf allen Endpunkten (JSON Schema)
- Keine SQL-Injection: IMMER Prepared Statements / ORM
- Keine direkten DB-Queries mit String-Interpolation

### API-Versionierung
- Alle Endpunkte unter `/api/v1/` versionieren
- Breaking Changes = neue Version (`/api/v2/`)
- Backward Compatibility f√ºr mindestens 1 Major Version
- Deprecation-Warnungen in Headers

### Idempotenz (KRITISCH)
- ALLE POST/PUT/PATCH Endpunkte M√úSSEN idempotent sein
- Idempotency-Key im Header erforderlich f√ºr kritische Operationen
- Duplikate erkennen und gleiche Response zur√ºckgeben
- Keine doppelten Orders/Payments bei Retries

### Webhook-Sicherheit
- Webhook-Signaturen IMMER validieren (Stripe: X-Stripe-Signature, BTCPay: BTCPay-Sig)
- Webhook-Payloads niemals blind vertrauen
- Rate Limiting auf Webhook-Endpunkten
- Idempotente Webhook-Verarbeitung (gleiche Webhook-ID = keine Duplikate)

## üíæ Datenbank-Design

### Transaktionssicherheit
- Kritische Operationen (Order erstellen, Payment verarbeiten) in Transaktionen
- ACID-Compliance f√ºr alle Status-√Ñnderungen
- Keine Race Conditions bei Status-Updates
- Optimistic Locking f√ºr concurrent Updates

### Historisierung & Auditing
- JEDE Status-√Ñnderung in History-Tabellen schreiben
- `order_status_history` und `payment_status_history` sind Pflicht
- Timestamps mit Timezone (UTC)
- User/System-Information f√ºr Audit-Trail
- Keine L√∂schungen (Soft Deletes mit `deleted_at`)

### Datenintegrit√§t
- Foreign Keys f√ºr alle Referenzen
- NOT NULL Constraints wo sinnvoll
- Unique Constraints f√ºr Business-Keys (z.B. source + source_order_id)
- Check Constraints f√ºr Status-Validierung
- Indexes auf alle Foreign Keys und h√§ufig abgefragte Spalten

### Migrationen
- Alle DB-√Ñnderungen √ºber Migrations
- Keine direkten ALTER TABLE in Production
- Rollback-f√§hige Migrations
- Migrations sind versioniert und getestet

## üîÑ Event-Handling & Orchestrierung

### Event-Idempotenz
- Events M√úSSEN idempotent verarbeitet werden
- Event-ID als deduplizierungsschl√ºssel
- Gleiche Event-ID = keine doppelte Verarbeitung
- Event-History f√ºr Debugging & Reconciliation

### Retry-Mechanismen
- Exponential Backoff f√ºr fehlgeschlagene Events
- Dead Letter Queue f√ºr Events, die nach X Retries fehlschlagen
- Manuelle Retry-M√∂glichkeit f√ºr Support
- Keine endlosen Retry-Loops

### Callback-Mechanismen
- Callbacks an Channels (Woo/POS) M√úSSEN idempotent sein
- Retry-Logik f√ºr fehlgeschlagene Callbacks
- Timeout-Handling (max 30s f√ºr Callbacks)
- Callback-Status-Tracking (erfolgreich/fehlgeschlagen)

## üß™ Testing-Standards

### Test-Pyramide
- Unit Tests: 80% Coverage f√ºr Business-Logic
- Integration Tests: Alle API-Endpunkte
- E2E Tests: Komplette Flows (Woo ‚Üí HUB ‚Üí Stripe ‚Üí HUB ‚Üí Woo)
- Webhook-Simulationen: Stripe CLI, BTCPay Test-Server

### Test-Daten
- Keine Production-Daten in Tests
- Factory-Pattern f√ºr Test-Daten
- Isolierte Test-Datenbank
- Cleanup nach jedem Test

### Test-Kritikalit√§t
- Payment-Flows M√úSSEN getestet sein
- Order-Status-Transitions M√úSSEN getestet sein
- Webhook-Handler M√úSSEN getestet sein
- Idempotenz MUSS getestet sein

## üìù Code-Qualit√§t & Standards

### Clean Code
- Funktionen max. 50 Zeilen
- Klassen max. 300 Zeilen
- DRY: Don't Repeat Yourself
- SOLID-Prinzipien befolgen
- Meaningful Names (keine Abk√ºrzungen au√üer etablierten)

### Code-Organisation
```
/src
  /domains
    /order
      /services
      /models
      /repositories
    /payment
      /services
      /models
      /repositories
    /customer
    /event
  /adapters
    /woocommerce
    /stripe
    /btcpay
  /api
    /v1
      /orders
      /payments
      /webhooks
  /infrastructure
    /database
    /logging
    /monitoring
```

### Linting & Formatting
- ESLint/TSLint f√ºr TypeScript/JavaScript
- Prettier f√ºr Code-Formatting
- Pre-commit Hooks f√ºr Linting
- CI/CD Pipeline bricht bei Linting-Fehlern

### Type Safety
- TypeScript STRICTLY verwenden (kein `any`)
- Typen f√ºr alle API-Requests/Responses
- JSON Schema Validation f√ºr externe Inputs
- Runtime-Validierung mit Zod/Joi

## üöÄ Deployment & CI/CD

### CI/CD-Pipeline
- Automatische Tests bei jedem Commit
- Linting & Type-Checking vor Merge
- Automatisches Deployment nach erfolgreichen Tests
- Staging-Environment vor Production
- Rollback-Strategie vorhanden

### Environment-Management
- Keine Secrets im Code
- Environment Variables f√ºr alle Konfigurationen
- Separate Configs f√ºr Dev/Staging/Production
- Database Migrations automatisch bei Deployment

### Monitoring & Observability
- Strukturierte Logs (JSON-Format)
- Log-Level: DEBUG, INFO, WARN, ERROR
- Request-ID f√ºr Request-Tracking
- Health-Checks f√ºr alle Services
- Metrics f√ºr kritische Operationen (Order-Creation, Payment-Processing)

## üîå Integration-Standards

### Payment-Provider-Adapter
- Einheitliche Adapter-Interface f√ºr alle Provider
- Provider-spezifische Logik isoliert
- Fehlerbehandlung pro Provider
- Retry-Logik pro Provider konfigurierbar

### Channel-Adapter (WooCommerce, POS, B2B)
- Mapping-Logik in Adaptern, nicht im Core
- Channel-spezifische Daten in `metadata` JSON-Feld
- Callback-URLs pro Channel konfigurierbar
- Fehlerbehandlung & Reconciliation pro Channel

### Webhook-Handler
- Provider-spezifische Handler (Stripe, BTCPay)
- Signature-Validierung MUSS
- Idempotente Verarbeitung
- Async-Verarbeitung f√ºr lange Operationen

## üö´ NOT-TO-DO Liste

### Was NIEMALS in den HUB geh√∂rt:
- ‚ùå Frontend-Logik (UI, Templates, CSS)
- ‚ùå WooCommerce-spezifische Business-Logik
- ‚ùå Payment-Provider-spezifische Logik im Core (nur in Adaptern)
- ‚ùå Direkte Datenbank-Zugriffe ohne Repository-Pattern
- ‚ùå Hardcoded Secrets oder API-Keys
- ‚ùå Synchrones Blocking auf externe APIs (au√üer kritischen Flows)
- ‚ùå Keine Validierung von Inputs
- ‚ùå Keine Error-Handling
- ‚ùå Direkte SQL-Queries mit String-Interpolation
- ‚ùå Keine Transaktionen bei kritischen Operationen
- ‚ùå Keine Idempotenz-Checks
- ‚ùå Keine Webhook-Signatur-Validierung

## üìä Performance & Skalierung

### Datenbank-Performance
- Indexes auf alle Foreign Keys
- Indexes auf h√§ufig abgefragte Spalten (status, source, created_at)
- Partitioning f√ºr gro√üe History-Tabellen (nach Datum)
- Query-Optimierung (keine N+1 Queries)

### API-Performance
- Pagination f√ºr List-Endpunkte (max 100 Items pro Request)
- Caching f√ºr nicht-kritische Daten (Customer-Info, etc.)
- Async-Verarbeitung f√ºr nicht-kritische Operationen
- Timeout-Handling f√ºr externe API-Calls (max 30s)

## üîç Code-Review-Checkliste

Vor jedem Merge pr√ºfen:
- [ ] Idempotenz implementiert?
- [ ] Input Validation vorhanden?
- [ ] Error Handling vorhanden?
- [ ] Tests geschrieben?
- [ ] Linting bestanden?
- [ ] Keine Secrets im Code?
- [ ] Transaktionen f√ºr kritische Operationen?
- [ ] History-Tabellen aktualisiert?
- [ ] Logging vorhanden?
- [ ] Dokumentation aktualisiert?

## üéØ Priorit√§ten

### P0 (Kritisch - Blockiert Release)
- Payment-Processing funktioniert
- Order-Status-Synchronisation funktioniert
- Webhook-Signatur-Validierung
- Idempotenz f√ºr alle kritischen Endpunkte

### P1 (Wichtig - Sollte im MVP sein)
- WooCommerce Integration
- Stripe Integration
- Order/Payment History
- Error Handling & Logging

### P2 (Nice-to-Have - Kann sp√§ter kommen)
- BTCPay Integration
- POS Integration
- B2B-Vertragsstrecke
- Erweiterte Monitoring-Dashboards

---

**Diese Regeln sind bindend f√ºr alle Entwickler. Bei Fragen oder Unklarheiten: CTO konsultieren.**



## üîÑ Arbeitsprozess & Entwicklungsmethodik

### Iterative Entwicklung mit To-Do-Management
- **IMMER zuerst**: Saubere, spezifische To-Dos definieren bevor Code geschrieben wird
- **To-Do-Struktur**: Jedes To-Do muss klar, testbar und abgrenzbar sein
- **Schritt-f√ºr-Schritt**: Nur EIN To-Do zur Zeit bearbeiten
- **Test-First**: Jeder Schritt MUSS getestet sein, bevor der n√§chste beginnt
- **Keine Parallel-Entwicklung**: Kein neues Feature starten, wenn das aktuelle nicht getestet ist

### To-Do-Definition (Pflicht vor jedem Feature)
Jedes To-Do MUSS enthalten:
1. **Klare Beschreibung**: Was wird implementiert?
2. **Akzeptanzkriterien**: Wann ist es fertig?
3. **Test-Plan**: Wie wird es getestet?
4. **Abh√§ngigkeiten**: Was muss vorher fertig sein?
5. **Sch√§tzung**: Realistische Zeitsch√§tzung

### Entwicklungszyklus (STRICT)
```
1. To-Do definieren & dokumentieren
   ‚Üì
2. Tests schreiben (TDD wenn m√∂glich)
   ‚Üì
3. Minimaler Code f√ºr To-Do
   ‚Üì
4. Tests laufen lassen & gr√ºn bekommen
   ‚Üì
5. Code-Review (selbst oder Team)
   ‚Üì
6. Linting & Formatting pr√ºfen
   ‚Üì
7. Integration testen (falls relevant)
   ‚Üì
8. To-Do als "Done" markieren
   ‚Üì
9. N√ÑCHSTES To-Do starten
```

### Testing zwischen Schritten
- **Unit Tests**: Nach jeder Funktion/Methode
- **Integration Tests**: Nach jedem API-Endpunkt
- **E2E Tests**: Nach jedem kompletten Flow
- **Manuelle Tests**: Nach jedem gr√∂√üeren Feature
- **Kein Commit**: Ohne gr√ºne Tests

### To-Do-Gr√∂√üe
- **Ideal**: 1-4 Stunden Arbeit
- **Maximum**: 1 Tag Arbeit
- **Zu gro√ü?**: To-Do in kleinere To-Dos aufteilen
- **Zu klein?**: Mehrere zusammengeh√∂rige To-Dos zusammenfassen

### Definition of Done (DoD)
Ein To-Do ist NUR fertig wenn:
- [ ] Code implementiert
- [ ] Tests geschrieben & gr√ºn
- [ ] Linting bestanden
- [ ] Code-Review durchgef√ºhrt (falls Team vorhanden)
- [ ] Dokumentation aktualisiert (falls n√∂tig)
- [ ] Keine bekannten Bugs
- [ ] Integration funktioniert (falls relevant)

### Fehlerbehandlung im Prozess
- **Tests schlagen fehl?**: Code fixen, nicht Tests anpassen (au√üer Test war falsch)
- **Linting-Fehler?**: Sofort fixen, nicht ignorieren
- **Unklare Anforderungen?**: STOPPEN, kl√§ren, dann weiter
- **Technische Schulden entdeckt?**: In separates To-Do auslagern, nicht jetzt fixen

### Kommunikation
- **Blockiert?**: Sofort kommunizieren, nicht stundenlang gr√ºbeln
- **To-Do gr√∂√üer als gedacht?**: Aufteilen oder Sch√§tzung anpassen
- **Unklarheit?**: Fragen stellen, nicht raten

## üèóÔ∏è Architektur-Prinzipien

### Modularer Monolith (NICHT Microservices)
- Wir bauen einen modularen Monolithen, keine Microservices
- Klare Dom√§nentrennung: Order, Payment, Customer, Event
- Jede Dom√§ne hat eigene Services, aber l√§uft im selben Prozess
- Keine verteilten Transaktionen - alles in einer DB
- Einfache Skalierung durch horizontales Scaling des gesamten Monolithen

### Single Source of Truth
- Die HUB-Datenbank ist die einzige Quelle der Wahrheit f√ºr Orders & Payments
- Externe Systeme (WooCommerce, POS) sind nur SPOKES - keine Autorit√§t
- Alle Status-√Ñnderungen gehen durch den HUB
- Keine direkte Kommunikation zwischen SPOKES

### Entkopplung & Abstraktion
- HUB kennt keine WooCommerce-spezifischen Details
- Payment-Provider sind √ºber Adapter abstrahiert
- Channels (Woo/POS/B2B) sind austauschbar
- Keine direkten Abh√§ngigkeiten zu externen Systemen im Core

## üîí Sicherheit & API-Design

### API-Sicherheit
- ALLE API-Endpunkte M√úSSEN authentifiziert sein (API Keys oder OAuth2)
- Webhook-Endpunkte M√úSSEN Signaturen validieren (Stripe, BTCPay)
- Rate Limiting auf allen √∂ffentlichen Endpunkten
- Input Validation auf allen Endpunkten (JSON Schema)
- Keine SQL-Injection: IMMER Prepared Statements / ORM
- Keine direkten DB-Queries mit String-Interpolation

### API-Versionierung
- Alle Endpunkte unter `/api/v1/` versionieren
- Breaking Changes = neue Version (`/api/v2/`)
- Backward Compatibility f√ºr mindestens 1 Major Version
- Deprecation-Warnungen in Headers

### Idempotenz (KRITISCH)
- ALLE POST/PUT/PATCH Endpunkte M√úSSEN idempotent sein
- Idempotency-Key im Header erforderlich f√ºr kritische Operationen
- Duplikate erkennen und gleiche Response zur√ºckgeben
- Keine doppelten Orders/Payments bei Retries

### Webhook-Sicherheit
- Webhook-Signaturen IMMER validieren (Stripe: X-Stripe-Signature, BTCPay: BTCPay-Sig)
- Webhook-Payloads niemals blind vertrauen
- Rate Limiting auf Webhook-Endpunkten
- Idempotente Webhook-Verarbeitung (gleiche Webhook-ID = keine Duplikate)

## üíæ Datenbank-Design

### Transaktionssicherheit
- Kritische Operationen (Order erstellen, Payment verarbeiten) in Transaktionen
- ACID-Compliance f√ºr alle Status-√Ñnderungen
- Keine Race Conditions bei Status-Updates
- Optimistic Locking f√ºr concurrent Updates

### Historisierung & Auditing
- JEDE Status-√Ñnderung in History-Tabellen schreiben
- `order_status_history` und `payment_status_history` sind Pflicht
- Timestamps mit Timezone (UTC)
- User/System-Information f√ºr Audit-Trail
- Keine L√∂schungen (Soft Deletes mit `deleted_at`)

### Datenintegrit√§t
- Foreign Keys f√ºr alle Referenzen
- NOT NULL Constraints wo sinnvoll
- Unique Constraints f√ºr Business-Keys (z.B. source + source_order_id)
- Check Constraints f√ºr Status-Validierung
- Indexes auf alle Foreign Keys und h√§ufig abgefragte Spalten

### Migrationen
- Alle DB-√Ñnderungen √ºber Migrations
- Keine direkten ALTER TABLE in Production
- Rollback-f√§hige Migrations
- Migrations sind versioniert und getestet

## üîÑ Event-Handling & Orchestrierung

### Event-Idempotenz
- Events M√úSSEN idempotent verarbeitet werden
- Event-ID als deduplizierungsschl√ºssel
- Gleiche Event-ID = keine doppelte Verarbeitung
- Event-History f√ºr Debugging & Reconciliation

### Retry-Mechanismen
- Exponential Backoff f√ºr fehlgeschlagene Events
- Dead Letter Queue f√ºr Events, die nach X Retries fehlschlagen
- Manuelle Retry-M√∂glichkeit f√ºr Support
- Keine endlosen Retry-Loops

### Callback-Mechanismen
- Callbacks an Channels (Woo/POS) M√úSSEN idempotent sein
- Retry-Logik f√ºr fehlgeschlagene Callbacks
- Timeout-Handling (max 30s f√ºr Callbacks)
- Callback-Status-Tracking (erfolgreich/fehlgeschlagen)

## üß™ Testing-Standards

### Test-Pyramide
- Unit Tests: 80% Coverage f√ºr Business-Logic
- Integration Tests: Alle API-Endpunkte
- E2E Tests: Komplette Flows (Woo ‚Üí HUB ‚Üí Stripe ‚Üí HUB ‚Üí Woo)
- Webhook-Simulationen: Stripe CLI, BTCPay Test-Server

### Test-Daten
- Keine Production-Daten in Tests
- Factory-Pattern f√ºr Test-Daten
- Isolierte Test-Datenbank
- Cleanup nach jedem Test

### Test-Kritikalit√§t
- Payment-Flows M√úSSEN getestet sein
- Order-Status-Transitions M√úSSEN getestet sein
- Webhook-Handler M√úSSEN getestet sein
- Idempotenz MUSS getestet sein

## üìù Code-Qualit√§t & Standards

### Clean Code
- Funktionen max. 50 Zeilen
- Klassen max. 300 Zeilen
- DRY: Don't Repeat Yourself
- SOLID-Prinzipien befolgen
- Meaningful Names (keine Abk√ºrzungen au√üer etablierten)

### Code-Organisation
```
/src
  /domains
    /order
      /services
      /models
      /repositories
    /payment
      /services
      /models
      /repositories
    /customer
    /event
  /adapters
    /woocommerce
    /stripe
    /btcpay
  /api
    /v1
      /orders
      /payments
      /webhooks
  /infrastructure
    /database
    /logging
    /monitoring
```

### Linting & Formatting
- ESLint/TSLint f√ºr TypeScript/JavaScript
- Prettier f√ºr Code-Formatting
- Pre-commit Hooks f√ºr Linting
- CI/CD Pipeline bricht bei Linting-Fehlern

### Type Safety
- TypeScript STRICTLY verwenden (kein `any`)
- Typen f√ºr alle API-Requests/Responses
- JSON Schema Validation f√ºr externe Inputs
- Runtime-Validierung mit Zod/Joi

## üöÄ Deployment & CI/CD

### CI/CD-Pipeline
- Automatische Tests bei jedem Commit
- Linting & Type-Checking vor Merge
- Automatisches Deployment nach erfolgreichen Tests
- Staging-Environment vor Production
- Rollback-Strategie vorhanden

### Environment-Management
- Keine Secrets im Code
- Environment Variables f√ºr alle Konfigurationen
- Separate Configs f√ºr Dev/Staging/Production
- Database Migrations automatisch bei Deployment

### Monitoring & Observability
- Strukturierte Logs (JSON-Format)
- Log-Level: DEBUG, INFO, WARN, ERROR
- Request-ID f√ºr Request-Tracking
- Health-Checks f√ºr alle Services
- Metrics f√ºr kritische Operationen (Order-Creation, Payment-Processing)

## üîå Integration-Standards

### Payment-Provider-Adapter
- Einheitliche Adapter-Interface f√ºr alle Provider
- Provider-spezifische Logik isoliert
- Fehlerbehandlung pro Provider
- Retry-Logik pro Provider konfigurierbar

### Channel-Adapter (WooCommerce, POS, B2B)
- Mapping-Logik in Adaptern, nicht im Core
- Channel-spezifische Daten in `metadata` JSON-Feld
- Callback-URLs pro Channel konfigurierbar
- Fehlerbehandlung & Reconciliation pro Channel

### Webhook-Handler
- Provider-spezifische Handler (Stripe, BTCPay)
- Signature-Validierung MUSS
- Idempotente Verarbeitung
- Async-Verarbeitung f√ºr lange Operationen

## üö´ NOT-TO-DO Liste

### Was NIEMALS in den HUB geh√∂rt:
- ‚ùå Frontend-Logik (UI, Templates, CSS)
- ‚ùå WooCommerce-spezifische Business-Logik
- ‚ùå Payment-Provider-spezifische Logik im Core (nur in Adaptern)
- ‚ùå Direkte Datenbank-Zugriffe ohne Repository-Pattern
- ‚ùå Hardcoded Secrets oder API-Keys
- ‚ùå Synchrones Blocking auf externe APIs (au√üer kritischen Flows)
- ‚ùå Keine Validierung von Inputs
- ‚ùå Keine Error-Handling
- ‚ùå Direkte SQL-Queries mit String-Interpolation
- ‚ùå Keine Transaktionen bei kritischen Operationen
- ‚ùå Keine Idempotenz-Checks
- ‚ùå Keine Webhook-Signatur-Validierung

## üìä Performance & Skalierung

### Datenbank-Performance
- Indexes auf alle Foreign Keys
- Indexes auf h√§ufig abgefragte Spalten (status, source, created_at)
- Partitioning f√ºr gro√üe History-Tabellen (nach Datum)
- Query-Optimierung (keine N+1 Queries)

### API-Performance
- Pagination f√ºr List-Endpunkte (max 100 Items pro Request)
- Caching f√ºr nicht-kritische Daten (Customer-Info, etc.)
- Async-Verarbeitung f√ºr nicht-kritische Operationen
- Timeout-Handling f√ºr externe API-Calls (max 30s)

## üîç Code-Review-Checkliste

Vor jedem Merge pr√ºfen:
- [ ] Idempotenz implementiert?
- [ ] Input Validation vorhanden?
- [ ] Error Handling vorhanden?
- [ ] Tests geschrieben?
- [ ] Linting bestanden?
- [ ] Keine Secrets im Code?
- [ ] Transaktionen f√ºr kritische Operationen?
- [ ] History-Tabellen aktualisiert?
- [ ] Logging vorhanden?
- [ ] Dokumentation aktualisiert?

## üéØ Priorit√§ten

### P0 (Kritisch - Blockiert Release)
- Payment-Processing funktioniert
- Order-Status-Synchronisation funktioniert
- Webhook-Signatur-Validierung
- Idempotenz f√ºr alle kritischen Endpunkte

### P1 (Wichtig - Sollte im MVP sein)
- WooCommerce Integration
- Stripe Integration
- Order/Payment History
- Error Handling & Logging

### P2 (Nice-to-Have - Kann sp√§ter kommen)
- BTCPay Integration
- POS Integration
- B2B-Vertragsstrecke
- Erweiterte Monitoring-Dashboards

---

**Diese Regeln sind bindend f√ºr alle Entwickler. Bei Fragen oder Unklarheiten: CTO konsultieren.**

